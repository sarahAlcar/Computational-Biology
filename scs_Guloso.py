#-----------------------------------------------------------------------------------------------
# Computacional Biology 
#
# Greedy approach to shortest common superstring (SCS) 
#  using overlapping graphs 
#
#-----------------------------------------------------------------------------------------------

import numpy as np
from collections import defaultdict 
import timeit
#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------
# Regarding fragments overlap
#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------
# findOverlappingPair(str1, str2, strN):
# Calculate the overlap between fragments of the set 
# output: maximum overlap value (maximo)
#-----------------------------------------------------------------------------------------------
def findOverlappingPair(str1, str2, strN):    	
        maximo = float('-inf') 
        len1 = len(str1)    
        len2 = len(str2)  
        minimo = min(len1, len2) 	
        for i in range(1,minimo):
            if (str1[-i:] == str2[:i]):
                if maximo < i:
                    maximo = i
                    strN = str1 + str2[i:]   	
        return maximo, strN
#-----------------------------------------------------------------------------------------------
# scsGuloso(arr, length):
# Create the weight matrix from the maximal overlays 
# output: matrix (grafo)
#-----------------------------------------------------------------------------------------------    
def scsGuloso(arr, length): 
    grafo = np.zeros((length,length))
    for i in range(length):
      for j in range(length):
         strN=' '                   
         res, strN = findOverlappingPair(arr[i], arr[j], strN) 
         grafo[i,j] = res
         if grafo[i,j] == float('-inf') or i==j:
             grafo[i,j] = 0
    return grafo

#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------
# Referring to find the greater weight edges in the overlapping graph
#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------
# find(i, parent):
# determining the vertex set i
#-----------------------------------------------------------------------------------------------
def find(i, parent): 
	while parent[i] != i: 
		i = parent[i]
	return i 
 
#-----------------------------------------------------------------------------------------------
# union1(i, j, parent):
# joins vertices i and j in the set of chosen elements
#-----------------------------------------------------------------------------------------------
def union1(i, j, parent): 
	a = find(i, parent) 
	b = find(j, parent) 
	parent[a] = b  

#-----------------------------------------------------------------------------------------------
# kruskalMST(cost, V, parent, matriz):
# Modified kruskal algorithm to find the largest edges of the graph instead of the smaller ones
# output : edges of the graph (matriz) that were selected during the process (path)
#-----------------------------------------------------------------------------------------------
def kruskalMST(cost, V, parent, matriz): 
	mincost = 0 # Cost of min MST.
	path = [[0 for x in range(V)] for y in range(V)]
	pesos = [None]*V
	p = 0
	# Initialize sets of disjoint sets. 
	for i in range (0,V): 
		parent[i] = i 

	# Include minimum weight edges one by one 
	edge_count = 0; 
	while edge_count < (V - 1):  
		#mini = float("inf")
		maxi = -float("inf")
		a = -1
		b = -1 
		for i in range (0,V): 
			for j in range (0,V): 
				if find(i,parent) != find(j, parent) and cost[i][j] > maxi: 
					maxi = cost[i][j] 
					a = i
					b = j  
		 
		union1(a, b, parent) 
		for i in range (0,V):
			cost[i][b] = -1
		for j in range (0,V):
			cost[a][j] = -1
		edge_count = edge_count + 1
		pesos [p] = int(maxi)
		p = p+1
		mincost = mincost + maxi 
		path[a][b] = 1
	return path

#-----------------------------------------------------------------------------------------------
# class Graph:
# class generated to be possible to execute a algorithm of topological ordering.
# The algorithm for topological ordering is executed to verify which sequence,
# from the path generated by the kruskalMST function, that the selected edges follow since
# path only shows which ones were selected but not your order.
#-----------------------------------------------------------------------------------------------

class Graph: 
    def __init__(self,vertices): 
        self.graph = defaultdict(list)  
        self.V = vertices #No. de vertices 
  
#-----------------------------------------------------------------------------------------------
# addEdge(self,u,v):
# adds edges to the graph
#----------------------------------------------------------------------------------------------- 
    def addEdge(self,u,v): 
        self.graph[u].append(v) 

#-----------------------------------------------------------------------------------------------
# topologicalSortUtil(self,v,visited,stack): 
# recursive function used during topological ordering
#-----------------------------------------------------------------------------------------------
    def topologicalSortUtil(self,v,visited,stack):  
        visited[v] = True
        for i in self.graph[v]: 
            if visited[i] == False: 
                self.topologicalSortUtil(i,visited,stack)  
        stack.insert(0,v) 
  
#-----------------------------------------------------------------------------------------------
# topologicalSort(self): 
# topological ordering of the vertices of the generated graph
#-----------------------------------------------------------------------------------------------
    def topologicalSort(self): 
        visited = [False]*self.V 
        stack =[] 
        for i in range(self.V): 
            if visited[i] == False: 
                self.topologicalSortUtil(i,visited,stack) 
        return stack 


#-----------------------------------------------------------------------------------------------
# orderWeights (sequence, matriz, V):
# function needed to sort the selected weights according to the correct path 
#-----------------------------------------------------------------------------------------------
def orderWeights (sequence, matriz, V):
	weight = [None]*(V-1)
	for i in range (0,V-1):
		weight [i] = matriz[sequence[i]][sequence[i+1]]
	return weight

#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------
# Referring to find the edges of greater weight in the overlapping graph
#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------


#-----------------------------------------------------------------------------------------------
# findSequence (sequence, peso, matriz, V):
# function that makes the association between weights and overlays of each vertice
# output: consensus sequence  
#-----------------------------------------------------------------------------------------------
def findSequence (sequence, peso, matriz, V):
	fragmento = ''
	overlap = int(peso[0])
	prefixo = matriz[sequence[0]]
	tamP = len(prefixo)-overlap
	sufixo = matriz[sequence[1]]
	fragmento = prefixo[:tamP] + sufixo
	for i in range (1,V-1):
		overlap = int(peso[i])
		sufixo = matriz[sequence[i+1]]
		fragmento = fragmento + sufixo[overlap:]
	return fragmento
	

#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------
# MAIN
#-----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------

def main():
    # reading the file containing the fragments 
    for a in range(5, 55, 5):  	
        arq = open("fragmentosR100S50F"+str(a)+".txt", 'r')
        arqFragmentos = open("Guloso-saidaS50F"+str(a)+".txt",'w')
        arqTempo= open("Guloso-tempoS50F"+str(a)+".txt",'w')
        texto = arq.readlines()
               
        cost= []
        for linha in texto :
            
            inicio = timeit.default_timer()
            
            cost = linha.split()
            V = len(cost)
            # Step 1: calculate the weight matrix from the maximal overlaps
            matriz= scsGuloso(cost, V)
            matriz1 = scsGuloso(cost, V)
            	
            parent = [None]*V
            # Step 2: get the highest value edges for scs overlapping
            path = kruskalMST(matriz, V, parent, cost) 
            	
            g = Graph(V) 
            for i in range(V):
            	for j in range(V):
            		if path[i][j] != 0:
            			g.addEdge(i,j)

            # Step 3: Sort the path found from the variable path 
            sequence = g.topologicalSort() 
            # Step 4: Sort the vector of weights of the edges according to the topology of step 3
            weights = orderWeights (sequence, matriz1, V)
            
            # Step 5: concatenate the fragments using the overlaps ordered in step 4
            frag = findSequence (sequence, weights, cost, V)
              
            
            arqFragmentos.write(str(len(frag)))
            arqFragmentos.write("\n")
            cost=[]
            fim = timeit.default_timer()
            arqTempo.write(str(fim-inicio))
            arqTempo.write("\n")
main ( )
